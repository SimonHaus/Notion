'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
INTRODUCTION
To add:
- convert types
- split using regex
- joining without a join
- filtering in the where statement with a new query (both from Camerons Query)
- FETCH FIRST 1000 ROWS ONLY;
- TOP (100)

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
-- SQL Code Repoistory
-- Created by: Simon Hausknecht
-- Script Pupose: Repository of learnt SQL skills
-- Updated: V1 08/09/2022

-- Contains:
-- - Table queries and sub queries
-- - Table filtering, ordering and limiting
-- - Table Joins
-- - Functions
-- - Regex
-- - Creating and deleting a database table

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' 
CODE
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

---- Contain a table query into name

WITH TABLE_NAME_NEW AS ( 

    SELECT *
    FROM TABLE_ONE
)

SELECT *
FROM TABLE_NAME_NEW


---- FUNCTION CASE WHEN

CASE 
WHEN [COLUMNA] > [COLUMNB] THEN [COLUMNC]
WHEN [COLUMND] LIKE 'STRING' THEN [COLUMNF]
WHEN [COLUMNG] NOT LIKE '%[0-9]' THEN 10
WHEN [COLUMNH] IS NULL THEN 11
ELSE
END

---- REGEX 

% -- ANY NUMBER OF CHARACTERS IN A STRING
[0-9] -- ANY SINGLE DIGIT BETWEEN 0 TO 9
[A-Z] -- ANY SINGLE LETTER BETWEEN A TO Z
[0-9][0-9][A-Z][A-Z] -- ANY 4 PART STRING WITH TWO DIGITS THEN TWO LETTERS


---- JOINS

-- NORMAL JOIN COLUMNS

FROM [DATABASE1].[TABLE1] D1T1
LEFT JOIN [DATABASE2].[TABLE2] D2T1
    ON D1T1.[KEYCOLUMN1] = D2T2.[KEYCOLUMN2]

-- SELECTIVE JOIN COLUMNS

FROM [DATABASE1].[TABLE1] D1T1
LEFT JOIN (SELECT [KEYCOLUMN2], [COLUMNX], [COLUMNY] FROM [DATABASE2].[TABLE2] WHERE [COLUMNZ] > 10) D2T1
    ON D1T1.[KEYCOLUMN1] = D2T2.[KEYCOLUMN2]

-- NORMAL JOIN ROWS (SAME COLUMN NAMES)

SELECT 
    [COLUMN1]
    [COLUMN2]
    [COLUMN3]

FROM [TABLE1]

UNION ALL 

SELECT 
    [COLUMN1]
    [COLUMN2]
    [COLUMN3]

FROM [TABLE2]

-- NOTE: ^ THIS CAN BE CONTAINED WITHIN A WITH _ AS _ STATEMENT AND THEN JOINED ONTO OTHER TABLES USING COLUMN JOINS


---- TABLE FILTERING WITH WHERE CLAUSES

WHERE [COLUMNA] > 10
 AND [TIMESTAMP] >= '2020-11-01 00:00:00'


---- ORDER QUERIES WITH ORDER BY

ORDER BY 
    [COLUMN1] DESC,
    [COLUMN2] DESC;

---- GET ALL TABLES AND COLUMNS FROM A SCHEMA (TO ENABLE EXCEL SEARCH)

SELECT TABLE_NAME,
        COLUMN_NAME
FROM INFORMATION_SCHEMA.COLUMNS

---- SELECT JUST TOP ROWS

SELECT TOP(100) *
FROM TABLE1

---- FUNCTIONS

-- DIFFERENCE BETWEEN TWO DATES
DATEDIFF(date_part,[START_TIME_COLUMN],[END_TIME_COLUMN]) -- date_part eg: second, minute, hour, day ect

-- ADD/SUBTRACT DATEPART FROM A TIMESTAMP
DATEADD(date_part,number,[TIMESTAMP_COLUMN]) -- date_part eg: second, minute, hour, day ect

-- CREATE A TIMETAMP FROM CURRENT TIME
CONVERT(DATETIME, CONCAT(DATEPART(YEAR,GETDATE()),'-',DATEPART(MONTH,GETDATE()),'-',DATEPART(DAY,GETDATE()),' ',DATEPART(HOUR,GETDATE()),':',DATEPART(MINUTE,GETDATE()),'-',DATEPART(SECOND,GETDATE())))

-- CREATE A TIMESTAMP FROM 6AM TODAY
CONVERT(DATETIME, CONCAT(DATEPART(YEAR,GETDATE()),'-',DATEPART(MONTH,GETDATE()),'-',DATEPART(DAY,GETDATE()),' 06:00:00'))

-- PARTITION AND ORDER OVER
FUNCTION([COLUMNA]) OVER (PARTITION BY [COLUMNB], [COLUMNC] ORDER BY [COLUMND], [COLUMNF]) -- FUNCTION REQUIRES AN AGGREGATION FUNCTION LIKE SUM, COUNT, AVG ECT

-- GET THE VALUE IN NEXT ROW
LEAD([COLUMNA]) OVER (PARTITION BY [COLUMNB] ORDER BY [COLUMNC])

-- GET TIMESTAMP
GETDATE() -- GET MACHINE TIMESTAMP
GETUTCDATE() -- GET UTC TIMESTAMP

-- STRING SEARCH
LEFT([COLUMN],2) -- GIVES FIRST TWO LETTERS
RIGHT([COLUMN],2) -- GIVES LAST TWO LETTERS

-- FUNCTIONS WITH GROUPBY
'YOU CAN USE FUCNTIONS SUCH AS SUM([COLUMN]) IF YOU HAVE GROUPBY STATEMENTS'

-- VALUE IF NULL
ISNULL([COLUMN],10)


---- CREATING A DATATABLE IN A DATABASE

USE [DATABASE_NAME]
GO

/** ADD TABLE DETAILS **/

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TABLE [TABLE_NAME](

    [ID] INT IDENTITY(1,1),
    [COLUMN_NAME] [DATA_TYPE] NULL / NOT NULL -- NOTE ANY KEY COLUMNS MUST BE NOT NULL
    [COULMNA] [NVARCHAR] (255) NOT NULL,
    [COULMNB] [BIGINT] NOT NULL,
    [COULMNC] [FLOAT] NULL,
    [COULMND] [TINYINT] NULL,
    [COULMNE] [DATETIME2] (3) NOT NULL,
    [COULMNF] [INT] NULL,

 CONSTRAINT [TABLE_NAME_PK] PRIMARY KEY CLUSTERED
(
    [COLUMNA] ASC,
    [COLUMNB] ASC
) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO


---- DELETING ING A DATATABLE IN A DATABASE

DELETE FROM [DB]

-- LIMIT WHAT IS DELETED
WITH DELETION AS
(
SELECT *,
    FUNCTION([COLUMNA] AS FILTER
FROM [DB])
)

DELETE D FROM DELETION D
WHERE D.[COLUMNBA] != D.[FILTER]

-- RESET IDENTITY COLUMN INDEX
DELETE FROM [DB] DBCC CHECKIDENT ("DB", RESEED, 1)














































